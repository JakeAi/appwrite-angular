{"version":3,"file":"appwrite-account.service.js","sourceRoot":"","sources":["../../../../../../../libs/appwrite/angular/src/lib/services/appwrite-account.service.ts"],"names":[],"mappings":"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","sourcesContent":["import { Injectable } from '@angular/core';\r\nimport { JWT, LogsList, Session, SessionsList, Token, User } from '@appwrite/common';\r\nimport URLParse from 'url-parse';\r\nimport { AppwriteException } from '../exceptions';\r\nimport { Payload } from '../types';\r\nimport { flatten } from '../util';\r\nimport { AppwriteService } from './';\r\n\r\n\r\n@Injectable()\r\nexport class AppwriteAccountService<T = User> {\r\n\r\n  constructor(\r\n    private appwriteService: AppwriteService,\r\n  ) {\r\n  }\r\n\r\n\r\n  /**\r\n   * Get Account\r\n   *\r\n   * Get currently logged in user data as JSON object.\r\n   *\r\n   * @throws {AppwriteException}\r\n   * @returns {Promise<T>>}\r\n   */\r\n  async get(): Promise<T> {\r\n    const path = '/account';\r\n    const payload: Payload = {};\r\n\r\n    return this.appwriteService.call<T>('GET', path, {\r\n      'content-type': 'application/json',\r\n    }, payload);\r\n  }\r\n\r\n  /**\r\n   * Create Account\r\n   *\r\n   * Use this endpoint to allow a new user to register a new account in your\r\n   * project. After the user registration completes successfully, you can use\r\n   * the [/account/verfication](/docs/client/account#accountCreateVerification)\r\n   * route to start verifying the user email address. To allow the new user to\r\n   * login to their new account, you need to create a new [account\r\n   * session](/docs/client/account#accountCreateSession).\r\n   *\r\n   * @param {string} email\r\n   * @param {string} password\r\n   * @param {string} name\r\n   * @throws {AppwriteException}\r\n   * @returns {Promise}\r\n   */\r\n  async create(email: string, password: string, name?: string): Promise<T> {\r\n    if (typeof email === 'undefined') {\r\n      throw new AppwriteException('Missing required parameter: \"email\"');\r\n    }\r\n\r\n    if (typeof password === 'undefined') {\r\n      throw new AppwriteException('Missing required parameter: \"password\"');\r\n    }\r\n\r\n    const path = '/account';\r\n    const payload: Payload = {};\r\n\r\n    if (typeof email !== 'undefined') {\r\n      payload['email'] = email;\r\n    }\r\n\r\n    if (typeof password !== 'undefined') {\r\n      payload['password'] = password;\r\n    }\r\n\r\n    if (typeof name !== 'undefined') {\r\n      payload['name'] = name;\r\n    }\r\n\r\n    return await this.appwriteService.call<T>('POST', path, {\r\n      'content-type': 'application/json',\r\n    }, payload);\r\n  }\r\n\r\n  /**\r\n   * Delete Account\r\n   *\r\n   * Delete a currently logged in user account. Behind the scene, the user\r\n   * record is not deleted but permanently blocked from any access. This is done\r\n   * to avoid deleted accounts being overtaken by new users with the same email\r\n   * address. Any user-related resources like documents or storage files should\r\n   * be deleted separately.\r\n   *\r\n   * @throws {AppwriteException}\r\n   * @returns {Promise}\r\n   */\r\n  async delete(): Promise<void> {\r\n    const path = '/account';\r\n    const payload: Payload = {};\r\n\r\n    return await this.appwriteService.call<void>('DELETE', path, {\r\n      'content-type': 'application/json',\r\n    }, payload);\r\n  }\r\n\r\n  /**\r\n   * Update Account Email\r\n   *\r\n   * Update currently logged in user account email address. After changing user\r\n   * address, user confirmation status is being reset and a new confirmation\r\n   * mail is sent. For security measures, user password is required to complete\r\n   * this request.\r\n   * This endpoint can also be used to convert an anonymous account to a normal\r\n   * one, by passing an email address and a new password.\r\n   *\r\n   * @param {string} email\r\n   * @param {string} password\r\n   * @throws {AppwriteException}\r\n   * @returns {Promise}\r\n   */\r\n  async updateEmail(email: string, password: string): Promise<T> {\r\n    if (typeof email === 'undefined') {\r\n      throw new AppwriteException('Missing required parameter: \"email\"');\r\n    }\r\n\r\n    if (typeof password === 'undefined') {\r\n      throw new AppwriteException('Missing required parameter: \"password\"');\r\n    }\r\n\r\n    const path = '/account/email';\r\n    const payload: Payload = {};\r\n\r\n    if (typeof email !== 'undefined') {\r\n      payload['email'] = email;\r\n    }\r\n\r\n    if (typeof password !== 'undefined') {\r\n      payload['password'] = password;\r\n    }\r\n\r\n    return await this.appwriteService.call<T>('PATCH', path, {\r\n      'content-type': 'application/json',\r\n    }, payload);\r\n  }\r\n\r\n  /**\r\n   * Create Account JWT\r\n   *\r\n   * Use this endpoint to create a JSON Web Token. You can use the resulting JWT\r\n   * to authenticate on behalf of the current user when working with the\r\n   * Appwrite server-side API and SDKs. The JWT secret is valid for 15 minutes\r\n   * from its creation and will be invalid if the user will logout in that time\r\n   * frame.\r\n   *\r\n   * @throws {AppwriteException}\r\n   * @returns {Promise}\r\n   */\r\n  async createJWT(): Promise<JWT> {\r\n    const path = '/account/jwt';\r\n    const payload: Payload = {};\r\n\r\n    return await this.appwriteService.call<JWT>('POST', path, {\r\n      'content-type': 'application/json',\r\n    }, payload);\r\n  }\r\n\r\n  /**\r\n   * Get Account Logs\r\n   *\r\n   * Get currently logged in user list of latest security activity logs. Each\r\n   * log returns user IP address, location and date and time of log.\r\n   *\r\n   * @throws {AppwriteException}\r\n   * @returns {Promise}\r\n   */\r\n  async getLogs(): Promise<LogsList> {\r\n    const path = '/account/logs';\r\n    const payload: Payload = {};\r\n\r\n    return await this.appwriteService.call<LogsList>('GET', path, {\r\n      'content-type': 'application/json',\r\n    }, payload);\r\n  }\r\n\r\n  /**\r\n   * Update Account Name\r\n   *\r\n   * Update currently logged in user account name.\r\n   *\r\n   * @param {string} name\r\n   * @throws {AppwriteException}\r\n   * @returns {Promise}\r\n   */\r\n  async updateName(name: string): Promise<User> {\r\n    if (typeof name === 'undefined') {\r\n      throw new AppwriteException('Missing required parameter: \"name\"');\r\n    }\r\n\r\n    const path = '/account/name';\r\n    const payload: Payload = {};\r\n\r\n    if (typeof name !== 'undefined') {\r\n      payload['name'] = name;\r\n    }\r\n\r\n    return await this.appwriteService.call<User>('PATCH', path, {\r\n      'content-type': 'application/json',\r\n    }, payload);\r\n  }\r\n\r\n  /**\r\n   * Update Account Password\r\n   *\r\n   * Update currently logged in user password. For validation, user is required\r\n   * to pass in the new password, and the old password. For users created with\r\n   * OAuth and Team Invites, oldPassword is optional.\r\n   *\r\n   * @param {string} password\r\n   * @param {string} oldPassword\r\n   * @throws {AppwriteException}\r\n   * @returns {Promise}\r\n   */\r\n  async updatePassword(password: string, oldPassword?: string): Promise<T> {\r\n    if (typeof password === 'undefined') {\r\n      throw new AppwriteException('Missing required parameter: \"password\"');\r\n    }\r\n\r\n    const path = '/account/password';\r\n    const payload: Payload = {};\r\n\r\n    if (typeof password !== 'undefined') {\r\n      payload['password'] = password;\r\n    }\r\n\r\n    if (typeof oldPassword !== 'undefined') {\r\n      payload['oldPassword'] = oldPassword;\r\n    }\r\n\r\n    return await this.appwriteService.call<T>('PATCH', path, {\r\n      'content-type': 'application/json',\r\n    }, payload);\r\n  }\r\n\r\n  /**\r\n   * Get Account Preferences\r\n   *\r\n   * Get currently logged in user preferences as a key-value object.\r\n   *\r\n   * @throws {AppwriteException}\r\n   * @returns {Promise}\r\n   */\r\n  async getPrefs(): Promise<Record<string, any>> {\r\n    const path = '/account/prefs';\r\n    const payload: Payload = {};\r\n\r\n    return await this.appwriteService.call<Record<string, any>>('GET', path, {\r\n      'content-type': 'application/json',\r\n    }, payload);\r\n  }\r\n\r\n  /**\r\n   * Update Account Preferences\r\n   *\r\n   * Update currently logged in user account preferences. You can pass only the\r\n   * specific settings you wish to update.\r\n   *\r\n   * @param {object} prefs\r\n   * @throws {AppwriteException}\r\n   * @returns {Promise}\r\n   */\r\n  async updatePrefs(prefs: Record<string, any>): Promise<T> {\r\n    if (typeof prefs === 'undefined') {\r\n      throw new AppwriteException('Missing required parameter: \"prefs\"');\r\n    }\r\n\r\n    const path = '/account/prefs';\r\n    const payload: Payload = {};\r\n\r\n    if (typeof prefs !== 'undefined') {\r\n      payload['prefs'] = prefs;\r\n    }\r\n\r\n    return await this.appwriteService.call<T>('PATCH', path, {\r\n      'content-type': 'application/json',\r\n    }, payload);\r\n  }\r\n\r\n  /**\r\n   * Create Password Recovery\r\n   *\r\n   * Sends the user an email with a temporary secret key for password reset.\r\n   * When the user clicks the confirmation link he is redirected back to your\r\n   * app password reset URL with the secret key and email address values\r\n   * attached to the URL query string. Use the query string params to submit a\r\n   * request to the [PUT\r\n   * /account/recovery](/docs/client/account#accountUpdateRecovery) endpoint to\r\n   * complete the process. The verification link sent to the user's email\r\n   * address is valid for 1 hour.\r\n   *\r\n   * @param {string} email\r\n   * @param {string} url\r\n   * @throws {AppwriteException}\r\n   * @returns {Promise}\r\n   */\r\n  async createRecovery(email: string, url: string): Promise<Token> {\r\n    if (typeof email === 'undefined') {\r\n      throw new AppwriteException('Missing required parameter: \"email\"');\r\n    }\r\n\r\n    if (typeof url === 'undefined') {\r\n      throw new AppwriteException('Missing required parameter: \"url\"');\r\n    }\r\n\r\n    const path = '/account/recovery';\r\n    const payload: Payload = {};\r\n\r\n    if (typeof email !== 'undefined') {\r\n      payload['email'] = email;\r\n    }\r\n\r\n    if (typeof url !== 'undefined') {\r\n      payload['url'] = url;\r\n    }\r\n\r\n    return await this.appwriteService.call<Token>('POST', path, {\r\n      'content-type': 'application/json',\r\n    }, payload);\r\n  }\r\n\r\n  /**\r\n   * Complete Password Recovery\r\n   *\r\n   * Use this endpoint to complete the user account password reset. Both the\r\n   * **userId** and **secret** arguments will be passed as query parameters to\r\n   * the redirect URL you have provided when sending your request to the [POST\r\n   * /account/recovery](/docs/client/account#accountCreateRecovery) endpoint.\r\n   *\r\n   * Please note that in order to avoid a [Redirect\r\n   * Attack](https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.md)\r\n   * the only valid redirect URLs are the ones from domains you have set when\r\n   * adding your platforms in the console interface.\r\n   *\r\n   * @param {string} userId\r\n   * @param {string} secret\r\n   * @param {string} password\r\n   * @param {string} passwordAgain\r\n   * @throws {AppwriteException}\r\n   * @returns {Promise}\r\n   */\r\n  async updateRecovery(userId: string, secret: string, password: string, passwordAgain: string): Promise<Token> {\r\n    if (typeof userId === 'undefined') {\r\n      throw new AppwriteException('Missing required parameter: \"userId\"');\r\n    }\r\n\r\n    if (typeof secret === 'undefined') {\r\n      throw new AppwriteException('Missing required parameter: \"secret\"');\r\n    }\r\n\r\n    if (typeof password === 'undefined') {\r\n      throw new AppwriteException('Missing required parameter: \"password\"');\r\n    }\r\n\r\n    if (typeof passwordAgain === 'undefined') {\r\n      throw new AppwriteException('Missing required parameter: \"passwordAgain\"');\r\n    }\r\n\r\n    const path = '/account/recovery';\r\n    const payload: Payload = {};\r\n\r\n    if (typeof userId !== 'undefined') {\r\n      payload['userId'] = userId;\r\n    }\r\n\r\n    if (typeof secret !== 'undefined') {\r\n      payload['secret'] = secret;\r\n    }\r\n\r\n    if (typeof password !== 'undefined') {\r\n      payload['password'] = password;\r\n    }\r\n\r\n    if (typeof passwordAgain !== 'undefined') {\r\n      payload['passwordAgain'] = passwordAgain;\r\n    }\r\n\r\n    return await this.appwriteService.call<Token>('PUT', path, {\r\n      'content-type': 'application/json',\r\n    }, payload);\r\n  }\r\n\r\n  /**\r\n   * Get Account Sessions\r\n   *\r\n   * Get currently logged in user list of active sessions across different\r\n   * devices.\r\n   *\r\n   * @throws {AppwriteException}\r\n   * @returns {Promise}\r\n   */\r\n  async getSessions(): Promise<SessionsList> {\r\n    const path = '/account/sessions';\r\n    const payload: Payload = {};\r\n\r\n    return await this.appwriteService.call<SessionsList>('GET', path, {\r\n      'content-type': 'application/json',\r\n    }, payload);\r\n  }\r\n\r\n  /**\r\n   * Create Account Session\r\n   *\r\n   * Allow the user to login into their account by providing a valid email and\r\n   * password combination. This route will create a new session for the user.\r\n   *\r\n   * @param {string} email\r\n   * @param {string} password\r\n   * @throws {AppwriteException}\r\n   * @returns {Promise}\r\n   */\r\n  async createSession(email: string, password: string): Promise<Session> {\r\n    if (typeof email === 'undefined') {\r\n      throw new AppwriteException('Missing required parameter: \"email\"');\r\n    }\r\n\r\n    if (typeof password === 'undefined') {\r\n      throw new AppwriteException('Missing required parameter: \"password\"');\r\n    }\r\n\r\n    const path = '/account/sessions';\r\n    const payload: Payload = {};\r\n\r\n    if (typeof email !== 'undefined') {\r\n      payload['email'] = email;\r\n    }\r\n\r\n    if (typeof password !== 'undefined') {\r\n      payload['password'] = password;\r\n    }\r\n\r\n    return await this.appwriteService.call<Session>('POST', path, {\r\n      'content-type': 'application/json',\r\n    }, payload);\r\n  }\r\n\r\n  /**\r\n   * Delete All Account Sessions\r\n   *\r\n   * Delete all sessions from the user account and remove any sessions cookies\r\n   * from the end client.\r\n   *\r\n   * @throws {AppwriteException}\r\n   * @returns {Promise}\r\n   */\r\n  async deleteSessions(): Promise<void> {\r\n    const path = '/account/sessions';\r\n    const payload: Payload = {};\r\n\r\n    return await this.appwriteService.call<void>('DELETE', path, {\r\n      'content-type': 'application/json',\r\n    }, payload);\r\n  }\r\n\r\n  /**\r\n   * Create Anonymous Session\r\n   *\r\n   * Use this endpoint to allow a new user to register an anonymous account in\r\n   * your project. This route will also create a new session for the user. To\r\n   * allow the new user to convert an anonymous account to a normal account, you\r\n   * need to update its [email and\r\n   * password](/docs/client/account#accountUpdateEmail) or create an [OAuth2\r\n   * session](/docs/client/account#accountCreateOAuth2Session).\r\n   *\r\n   * @throws {AppwriteException}\r\n   * @returns {Promise}\r\n   */\r\n  async createAnonymousSession(): Promise<Session> {\r\n    const path = '/account/sessions/anonymous';\r\n    const payload: Payload = {};\r\n\r\n    return await this.appwriteService.call<Session>('POST', path, {\r\n      'content-type': 'application/json',\r\n    }, payload);\r\n  }\r\n\r\n  /**\r\n   * Create Account Session with OAuth2\r\n   *\r\n   * Allow the user to login to their account using the OAuth2 provider of their\r\n   * choice. Each OAuth2 provider should be enabled from the Appwrite console\r\n   * first. Use the success and failure arguments to provide a redirect URL's\r\n   * back to your app when login is completed.\r\n   *\r\n   * @param {string} provider\r\n   * @param {string} success\r\n   * @param {string} failure\r\n   * @param {string[]} scopes\r\n   * @throws {AppwriteException}\r\n   * @returns {void|URLParse}\r\n   */\r\n  async createOAuth2Session(provider: string, success?: string, failure?: string, scopes?: string[]): Promise<void | URLParse> {\r\n    if (typeof provider === 'undefined') {\r\n      throw new AppwriteException('Missing required parameter: \"provider\"');\r\n    }\r\n\r\n    const path = '/account/sessions/oauth2/{provider}'.replace('{provider}', provider);\r\n    const payload: Payload = {};\r\n\r\n    if (typeof success !== 'undefined') {\r\n      payload['success'] = success;\r\n    }\r\n\r\n    if (typeof failure !== 'undefined') {\r\n      payload['failure'] = failure;\r\n    }\r\n\r\n    if (typeof scopes !== 'undefined') {\r\n      payload['scopes'] = scopes;\r\n    }\r\n\r\n    const uri = new URLParse(this.appwriteService.config.endpoint + path);\r\n    payload['project'] = this.appwriteService.config.project;\r\n    uri.set('query', flatten(payload));\r\n\r\n    // @todo fix this in nativescript\r\n    if (typeof this.appwriteService.locationProvider !== 'undefined' && this.appwriteService.locationProvider) {\r\n      this.appwriteService.locationProvider.href = uri.toString();\r\n    } else {\r\n      return uri;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get Session By ID\r\n   *\r\n   * Use this endpoint to get a logged in user's session using a Session ID.\r\n   * Inputting 'current' will return the current session being used.\r\n   *\r\n   * @param {string} sessionId\r\n   * @throws {AppwriteException}\r\n   * @returns {Promise}\r\n   */\r\n  async getSession(sessionId: string): Promise<Session> {\r\n    if (typeof sessionId === 'undefined') {\r\n      throw new AppwriteException('Missing required parameter: \"sessionId\"');\r\n    }\r\n\r\n    const path = '/account/sessions/{sessionId}'.replace('{sessionId}', sessionId);\r\n    const payload: Payload = {};\r\n\r\n    return await this.appwriteService.call<Session>('GET', path, {\r\n      'content-type': 'application/json',\r\n    }, payload);\r\n  }\r\n\r\n  /**\r\n   * Delete Account Session\r\n   *\r\n   * Use this endpoint to log out the currently logged in user from all their\r\n   * account sessions across all of their different devices. When using the\r\n   * option id argument, only the session unique ID provider will be deleted.\r\n   *\r\n   * @param {string} sessionId\r\n   * @throws {AppwriteException}\r\n   * @returns {Promise}\r\n   */\r\n  async deleteSession(sessionId: string): Promise<void> {\r\n    if (typeof sessionId === 'undefined') {\r\n      throw new AppwriteException('Missing required parameter: \"sessionId\"');\r\n    }\r\n\r\n    const path = '/account/sessions/{sessionId}'.replace('{sessionId}', sessionId);\r\n    const payload: Payload = {};\r\n\r\n    return await this.appwriteService.call<void>('DELETE', path, {\r\n      'content-type': 'application/json',\r\n    }, payload);\r\n  }\r\n\r\n  /**\r\n   * Create Email Verification\r\n   *\r\n   * Use this endpoint to send a verification message to your user email address\r\n   * to confirm they are the valid owners of that address. Both the **userId**\r\n   * and **secret** arguments will be passed as query parameters to the URL you\r\n   * have provided to be attached to the verification email. The provided URL\r\n   * should redirect the user back to your app and allow you to complete the\r\n   * verification process by verifying both the **userId** and **secret**\r\n   * parameters. Learn more about how to [complete the verification\r\n   * process](/docs/client/account#accountUpdateVerification). The verification\r\n   * link sent to the user's email address is valid for 7 days.\r\n   *\r\n   * Please note that in order to avoid a [Redirect\r\n   * Attack](https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.md),\r\n   * the only valid redirect URLs are the ones from domains you have set when\r\n   * adding your platforms in the console interface.\r\n   *\r\n   *\r\n   * @param {string} url\r\n   * @throws {AppwriteException}\r\n   * @returns {Promise}\r\n   */\r\n  async createVerification(url: string): Promise<Token> {\r\n    if (typeof url === 'undefined') {\r\n      throw new AppwriteException('Missing required parameter: \"url\"');\r\n    }\r\n\r\n    const path = '/account/verification';\r\n    const payload: Payload = {};\r\n\r\n    if (typeof url !== 'undefined') {\r\n      payload['url'] = url;\r\n    }\r\n\r\n    return await this.appwriteService.call<Token>('POST', path, {\r\n      'content-type': 'application/json',\r\n    }, payload);\r\n  }\r\n\r\n  /**\r\n   * Complete Email Verification\r\n   *\r\n   * Use this endpoint to complete the user email verification process. Use both\r\n   * the **userId** and **secret** parameters that were attached to your app URL\r\n   * to verify the user email ownership. If confirmed this route will return a\r\n   * 200 status code.\r\n   *\r\n   * @param {string} userId\r\n   * @param {string} secret\r\n   * @throws {AppwriteException}\r\n   * @returns {Promise}\r\n   */\r\n  async updateVerification(userId: string, secret: string): Promise<Token> {\r\n    if (typeof userId === 'undefined') {\r\n      throw new AppwriteException('Missing required parameter: \"userId\"');\r\n    }\r\n\r\n    if (typeof secret === 'undefined') {\r\n      throw new AppwriteException('Missing required parameter: \"secret\"');\r\n    }\r\n\r\n    const path = '/account/verification';\r\n    const payload: Payload = {};\r\n\r\n    if (typeof userId !== 'undefined') {\r\n      payload['userId'] = userId;\r\n    }\r\n\r\n    if (typeof secret !== 'undefined') {\r\n      payload['secret'] = secret;\r\n    }\r\n\r\n    return await this.appwriteService.call<Token>('PUT', path, {\r\n      'content-type': 'application/json',\r\n    }, payload);\r\n  }\r\n\r\n}\r\n"]}